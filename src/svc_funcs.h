#pragma once

#include "portfolio.h"
#include "types.h"

Node*    svc_RemHead(List *);
void     svc_AddHead(List *, Node *);
Node*    svc_RemTail(List *);
void     svc_AddTail(List *, Node *);
void     svc_TailInsertNode(List *, Node *);
void     svc_RemNode(Node *);
void*    svc_AllocMemFromMemLists(List *l, u32 mem_size, u32 mem_flags);
void     svc_FreeMemToMemLists(List *l, void *mem, u32 mem_size);
void     svc_InitList(List *l, const char *name);
Node*    svc_FindNamedNode(const List *l, const char *name);
i32      svc_ScavengeMem(void);
void*    svc_LookupItem(Item i);
void*    svc_memset(void *s, int c, size_t n);
void*    svc_memcpy(void *dst, const void *src, size_t num_bytes);
i32      svc_GetPageSize(u32 typebits);
void*    svc_CheckItem(Item i, u8 ftype, u8 ntype);
void     svc_UniversalInsertNode(List *l, Node *n, int (*func)(Node *n, Node *m));
i32      svc_USec2Ticks(i32 usec);
u8       svc_SetNodePri(Node *n, u8 newpri);
void     svc_InsertNodeFromHead(List *l, Node *n);
//svc_vfprintf
i32      svc_GetSysErr(char *buf, i32 bufsize, Item err);
void*    svc_AllocMemFromMemList(MemList *ml, i32 size, u32 memflags);
void     svc_FreeMemToMemList(MemList *ml, void *p, i32 size);
MemList* svc_AllocMemList(const void *p, const char *name);
void     svc_FreeMemList(MemList *ml);
Err      svc_ItemOpened(Item task, Item i);
void     svc_ExitTask(i32 status);
//AIFHeader* svc_FindImage(AIFHeader *aif, u32 pagemask, char *aifname);
i32      svc_GetMemAllocAlignment(u32 memflags);
i32      svc_GetMemTrackSize(const void *p);
i32      svc_externalCheckIO(Item ior_item);
i32      svc_IsRamAddr(void *p, u32 size);
i32      svc_IsMemWritable(const void *p, i32 size);
TagArg*  svc_FindTagArg(const TagArg *tag_list, u32 tag);
TagArg*  svc_NextTagArg(const TagArg **tag_list);
Err      svc_internalDoIO(struct IOReq *);
Err      svc_internalWaitIO(struct IOReq *);
Item     svc_internalWaitPort(MsgPort *port, Msg *msg);
void     svc_internalReleaseDirectoryBuffer(void *buf, i32 size);
void*    svc_internalGetDirectoryBuffer(i32 *size);
void*    svc_internalGetDirectoryCache(i32 *size);
i32      svc_SectorECC(u8 *buf);
u32      svc_SetSysInfo(u32 tag, void *info, size_t infosize);
u32      svc_QuerySysInfo(u32 tag, void *info, size_t infosize);
i32      svc_internalReportEvent(void *event);
int      svc_internalRegisterSingleVBLACS(Item i);
int      svc_internalRegisterPeriodicVBLACS(Item i);
i32      svc_internalPendACS(Item i);
Item     svc_internalAllocACS(char *name, int pri, i32 (*code)());
Err      svc_internalFreeSignal(int32 signals, struct Task *task);
i32      svc_internalDeleteItem(Item i, struct Task *task);
i32      svc_LockItem(Item i, u32 flags);
i32      svc_internalLockSemaphore(struct Semaphore *s, i32);
Err      svc_UnlockItem(Item i);
i32      svc_internalUnlockSemaphore(struct Semaphore *s);
void     svc_TimeStamp(struct timeval *);
i32      svc_TagProcessor(void *n, TagArg *tagpt, i32 (*cb)(), void *data);
void     svc_Switch(void);
//svc_IsRamAddr
Err      svc_internalSignal(struct Task *t, i32 sig);
i32      svc_ValidateMem(struct Task * t, void *p, i32 size);
i32      svc_internalControlSuperMem(char *, i32, i32, Item);
void     svc_internalAbortIO(struct IOReq *ior);
void     svc_internalCompleteIO(struct IOReq *ior);
Item     svc_GetItem(void *p);
i32      svc_internalSendIO(struct IOReq *ior);
u32      svc_FirqInterruptControl(i32 int_num, i32 cmd);
void     svc_DebugTrigger(void);
void     svc_Enable(u32);
u32      svc_Disable(void);
i32      svc_internalPutMsg(struct MsgPort *msg, struct Msg *mp, void *data, i32 datasize);

Item  svc_internalCreateItem(i32, void *, i32);
i32   svc_internalWait(i32);
Err   svc_externalSignal(Item, i32);
i32   svc_externalDeleteItem(Item);
Item  svc_internalFindItem(i32, TagArg *);
Item  svc_internalOpenItem(Item, void *);
i32   svc_externalUnlockSemaphore(Item);
i32   svc_externalLockSemaphore(Item, i32);
i32   svc_externalCloseItem(Item);
void  svc_internalYield(void);
i32   svc_externalSetItemPriority(Item i, u8 pri);
void  svc_internalForbid(void);
void  svc_internalPermit(void);
void* svc_internalAllocMemBlocks(i32, i32);
void  svc_kprintf(const char *fmt, ...);
Item  svc_internalGetThisMsg(Item msg);
i32   svc_externalPutMsg(Item mp, Item msg, void *data, i32 datasize);
u32   svc_ReadHardwareRandomNumber(void);
i32   svc_externalReplyMsg(Item msg, i32 result, void *data, i32 datasize);
Item  svc_internalGetMsg(Item mp);
Err   svc_externalControlMem(void *p, i32 size, i32 cmd, Item task);
i32   svc_internalAllocSignal(u32 sigmask);
Err   svc_externalFreeSignal(u32 sigmask);
void* svc_internalSetFunction(Item item, i32 vnum, i32 vtype, void *func);
Err   svc_externalSendIO(Item ior, const IOInfo *ioi);
Err   svc_externalAbortIO(Item ior);
i32   svc_RSACheck(uchar *buf, i32 bufsize);
i32   svc_wcopy(i32 *src, i32 *dst, i32 cnt);
Err   svc_externalSetItemOwner(Item i, Item newowner);
Err   svc_callbacksuper(Err (*code)(), u32 arg1, u32 arg2, u32 arg3);
int   svc_MayGetChar(void);
i32   svc_externalSystemScavengeMem(void);
void  svc_externalCompleteIO(IOReq *ior);
u32   svc_internalDiscOsVersion(u32 set);
Item  svc_externalFindAndOpenItem(i32 ctype,TagArg *tp);
Err   svc_externalDoIO(Item ior, const IOInfo *ioi);
u32   svc_SampleSystemTime(void);
Err   svc_externalSetExitStatus(i32 status);
Item  svc_externalWaitPort(Item mp, Item msg);
Err   svc_externalWaitIO(Item ior);
void  svc_internalPrint3DOHeader(void *p3do, char *whatstr, char *copystr);
// Err svc_internalSetSystemState(u32 tag, void *info, size_t infosize);
